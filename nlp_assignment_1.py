# -*- coding: utf-8 -*-
"""NLP Assignment 1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1NCRd_fVjJUEORcZx3kWEPrjPWftNT87j
"""

from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_squared_error, r2_score
import pandas as pd
import numpy as np

dataset=pd.read_csv('/content/Housing.csv')
dataset=dataset.dropna()
dataset.head(10)

Y = dataset['median_house_value']
X = dataset.loc[:,'longitude':'median_income']

x_train,x_test,y_train,y_test = train_test_split(X,Y,test_size=0.3,random_state=2003)

x_train_np=x_train.to_numpy()
y_train_np=y_train.to_numpy()

x_test_np=x_test.to_numpy()
y_test_np=y_test.to_numpy()

import matplotlib.pyplot as plt
columns = dataset.columns.drop(['ocean_proximity'])
x_axis = range(0, 25)
fig, axis = plt.subplots(9, 1)
count=0
for column in columns:
    axis[count].plot(x_axis, dataset.head(25)[column], label=column)
    axis[count].legend()
    count=count+1

import torch
from torch.nn import Conv1d
from torch.nn import MaxPool1d
from torch.nn import Flatten
from torch.nn import Sequential
from torch.nn import Linear
from torch.nn import Softmax
from torch.nn.functional import relu
from torch.nn.functional import softmax
from torch.utils.data import DataLoader, TensorDataset

class CnnRegressor(torch.nn.Module):
  def __init__(self,batch_size,inputs,outputs):
    super(CnnRegressor,self).__init__()
    self.batch_size=batch_size
    self.inputs=inputs
    self.outputs=outputs
    
    self.input_layer=Conv1d(inputs,batch_size,1)
    self.max_pooling_layer = MaxPool1d(1)
    self.conv_layer=Conv1d(batch_size,256,1)
    self.conv_layer2=Conv1d(256,256,1)
    self.flatten_layer=Flatten()
    self.non_linear_layer=Sequential(Linear(256,256))
    self.output_layer=Sequential(Linear(256,outputs))

  def feed(self,input):
    input=input.reshape((self.batch_size,self.inputs,1))
    output=relu(self.input_layer(input))
    output=self.max_pooling_layer(output)
    output=relu(self.conv_layer(output))
    output=relu(self.conv_layer2(output))
    output=self.flatten_layer(output)
    output=self.non_linear_layer(output)
    output=self.output_layer(output)
    return output

from torch.optim import SGD
from torch.nn import L1Loss
!pip install pytorch-ignite
from ignite.contrib.metrics.regression.r2_score import R2Score

batch_size=64
model = CnnRegressor(batch_size,X.shape[1],1)
model.cuda()

def model_loss(model,dataset,train=False,optimizer=None):
  performance=L1Loss()
  score_metric=R2Score()
  avg_loss=0
  avg_score=0
  count=0

  for input,output in iter(dataset):
    predictions=model.feed(input)
    loss=performance(predictions,output)
    score_metric.update([predictions,output])
    score=score_metric.compute()
    if(train):
      optimizer.zero_grad()
      loss.backward()
      optimizer.step()
    avg_loss+=loss.item()
    avg_score+=score
    count+=1
  return avg_loss/count, avg_score/count

epochs=100
optimizer=SGD(model.parameters(),lr=1e-5)
inputs=torch.from_numpy(x_train_np).cuda().float()
outputs=torch.from_numpy(y_train_np.reshape(y_train_np.shape[0],1)).cuda().float()

tensor=TensorDataset(inputs,outputs)
loader=DataLoader(tensor,batch_size,shuffle=True,drop_last=True)

for epoch in range(epochs):
  avg_loss,avg_r2_score=model_loss(model,loader,train=True,optimizer=optimizer)
  print("Epoch "+str(epoch+1)+":\n\tLoss = "+str(avg_loss)+"\n\tR2 Score = "+str(avg_r2_score))

inputs=torch.from_numpy(x_test_np).cuda().float()
outputs=torch.from_numpy(y_test_np.reshape(y_test_np.shape[0],1)).cuda().float()

tensor=TensorDataset(inputs,outputs)
loader=DataLoader(tensor,batch_size,shuffle=True,drop_last=True)

avg_loss,avg_r2_score=model_loss(model,loader)
print("The models L1 Loss is: "+str(avg_loss))
print("The models R2 score is: "+str(avg_r2_score))